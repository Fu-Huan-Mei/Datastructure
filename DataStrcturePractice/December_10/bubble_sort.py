
'''
常见排序算法
1、low：冒泡排序、选择排序、插入排序
2、NB：快速排序、堆排序、归并排序
3、其他：希尔排序、计数排序、基数排序
'''
import random
#li = [1,2,3,4]
# #趟：len(li)-1  从0开始计算               i  0 1 2 3   len(li)-1=5-1=4
# #无序区：len(li) - i - 1                    4 3 2 1    len(li)-i-1=5-3-1=1（最后一趟不需要遍历已经排好序了）
# #有序区：i+1                                1 2 3 4    i + 1
# #默认升序排列
def bubble_sort(li):
 # type: ignore # type: ignore # type: ignore	#i表示趟数，i从0开始计算
	for i in range(len(li)-1):
		#遍历无序区
		for j in range(len(li)-i-1):
			if li[j] > li[j+1]:
				li[j],li[j+1] = li[j+1],li[j]
		print(f'第{i}趟结束后的排序情况：',li)
		
li = [random.randint(0,100) for i in range(10)]
print('排序前:',li)
print('*'*130)
bubble_sort(li)
print('升序后:',li)
'''
运行结果：
排序前: [9, 63, 67, 15, 36, 44, 82, 47, 93, 69]
****************************************************************************************************
第0趟结束后的排序情况： [6, 40, 25, 88, 68, 68, 38, 8, 62, 95]
第1趟结束后的排序情况： [6, 25, 40, 68, 68, 38, 8, 62, 88, 95]
第2趟结束后的排序情况： [6, 25, 40, 68, 38, 8, 62, 68, 88, 95]
第3趟结束后的排序情况： [6, 25, 40, 38, 8, 62, 68, 68, 88, 95]
第4趟结束后的排序情况： [6, 25, 38, 8, 40, 62, 68, 68, 88, 95]
第5趟结束后的排序情况： [6, 25, 8, 38, 40, 62, 68, 68, 88, 95]
发现问题：第5趟结束以后列表已经排号升序了，所以无序再做以下的排序
解决问题：可以改进这里，提高性能
第6趟结束后的排序情况： [6, 8, 25, 38, 40, 62, 68, 68, 88, 95]
第7趟结束后的排序情况： [6, 8, 25, 38, 40, 62, 68, 68, 88, 95]
第8趟结束后的排序情况： [6, 8, 25, 38, 40, 62, 68, 68, 88, 95]
第九趟已经排好顺序了
****************************************************************************************************
升序后: [9, 15, 36, 44, 47, 63, 67, 69, 82, 93]
'''
#改进后
print('*'*130)
def bubble_sort(li):
	#i表示趟数，i从0开始计算
	for i in range(len(li)-1):
		exchange = False
		#遍历无序区
		for j in range(len(li)-i-1):
			if li[j] > li[j+1]:
				li[j],li[j+1] = li[j+1],li[j]
				exchange = True
		print(f'第{i}趟结束后的排序情况：',li)
		#一趟结束以后，如果没有发生交换，则结束一趟的循环即已经排序完成了
		if not exchange:
			return 
		
li = [random.randint(0,100) for i in range(10)]
print('改进后的排序前:',li)
print('*'*130)
bubble_sort(li)
print('改进后的升序后:',li)



# print('*'*130)

# #冒泡排序：降序排列
# def bubble_sort(li):
# 	#趟数：每一趟排好一个数
# 	for i in range(len(li)-1):
# 		#无序区
# 		for j in range(len(li)-i-1):
# 			if li[j] > li[j+1]:
# 				li[j],li[j+1] = li[j+1],li[j]
# 		print(f'第{i}趟结束后的排序情况：',li)
	
		
# li = [random.randint(0,100) for i in range(10)]
# print('排序前:',li)
# print('*'*130)
# bubble_sort(li)
# print('降序后：',li)

